@page "/weather"
@inject HttpClient Http
@inject NavigationManager UriHelper
@inject NavigationManager NavigationManager
@using Instrukcja.Model
@using Instrukcja.Services
@using Microsoft.Data.Sqlite;
@using Blazorise.Charts;
@using Blazorise.Charts.Annotation;
@using System;
@using System.Net.Http;
@using System.Threading.Tasks;
@using Newtonsoft.Json;
@using System.Globalization;
@inject WeatherService WeatherService
@inject ReadDataBaseService ReadData

<h1>Weather Overview</h1>

@if (weatherData != null) //jeżeli udało nam się dostać dane z api
{
    <p>Lat: @weatherData.Lat</p>
    <p>Lon: @weatherData.Lon</p>
    foreach (var day in labels) //dla każego dnia w liście labels wyświetlamy sobie zawartość - w tym przypadku datę
    {
        <p>Labels: @day</p>
    }
    foreach (var tem in data) //dla każdego tem(od temperatury) w liście data wypisujemy wszystkie temperatury - dnia, nocy, minimalna, maksymalna, poranna i popołudniowa
    {
        <p>Temperature Day: @tem.Day</p>
        <p>Temperature Night: @tem.Night</p>
        <p>Temperature Min: @tem.Min</p>
        <p>Temperature Max: @tem.Max</p>
        <p>Temperature Eve: @tem.Eve</p>
        <p>Temperature Morn: @tem.Morn</p>
    }
}
else // jeżeli nie to normalnie wyświetla się ten komunikat
{
    <p>Loading weather data...</p>
}

@code {
    //potrzebne do frontu
    private string inputCity = "Warszawa"; //wpisywanie miasta dla, którego chcemy sprawdzić pogode - na razie z ręki ale trzeba zrobić, żeby się dało z klawiatury
    private List<string> labels; //lista o typie string - wczytujemy do niej daty przekonwertowane na string z weatherDailies - u góry jest
    private List<Temperature> data; //lista o typie Temperature - /Model/Temperature.cs do której wczytujemy z weatherDailies obiekty Temp żeby później wyświetlać i wykonywać operacje na danych o temperaturze w ciągu dnia
    private WeatherDataResult weatherDataResult; //definicja nowego obiektu do którego wczytujemy dane z bazy danych - zdefiniowana w /Model/WeatherDataResult.cs 
    private List<WeatherDaily> weatherDailies = new List<WeatherDaily>(); //lista o typie WeatherDaily - /Model/WeatherDaily.cs do której przekazujemy wyłącznie część odpowiedzi z bazy danych żeby łatwiej było to ogarniać
    
    //raczej nie potrzebne do frontu
    private Location location;
    private WeatherResponse weatherData; // definicja nowej klasy do której są wczytywane dane z api - klasa zdefiniowana w /Model/WeatherResponse.cs
    //private LineChart<double> lineChart; //in development - miał być do wykresu liniowego jakiś tam komponent ale jeszcze nie zrobiłem
    //private LineChartOptions chartOptions; //tak samo jak u góry
    
                                                                          //
    

    public static DateTime UnixTimeStampToDateTime(long unixTimeStamp) //funkcja do przekonwertowania czasu w formacie Unixowym na DateTime
    {
        // Ustawienie punktu początkowego (epoch)
        System.DateTime dtDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, System.DateTimeKind.Utc);
        // Dodanie liczby sekund
        dtDateTime = dtDateTime.AddSeconds(unixTimeStamp).ToLocalTime();
        return dtDateTime;
    }

    protected override async Task OnParametersSetAsync() //Wywołuje się za każdym razem, gdy parametry komponentu są ustawione //WAŻNE - ZROBIĆ BUTTON SEARCH, KTÓRY BĘDZIE PRZEŁADOWYWAŁ STRONĘ ZA KAŻDYM WYSZUKANIEM NOWEGO MIEJSCA
    {
        await FetchWeatherDataAsync(); //pobieranie danych z API oraz dodawanie do bazy danych i w przyszłości updatowanie w bazie danych
        weatherDataResult = await ReadData.GetLast10WeatherDailiesWithHourliesAsync(inputCity); //ściąganie danych z bazy danych do obiektu weatherDataResult

        if (weatherDataResult != null)
        {
            weatherDailies = weatherDataResult.DailiesData; //Wyciągam jedynie dane dzienne ( są jeszcze godzinowe )
            labels = weatherDailies.Select(d => d.DateDaily.ToString()).ToList(); //do listy labels dodaję wyłącznie daty w formacie string
            data = weatherDailies.Select(d => d.Temp).ToList(); // do listy data dodaję obiekty Temp z temperaturami
        }
    }

    private async Task<WeatherResponse> FetchWeatherDataAsync() //funkcja do pobierania danych z api, fetchowania ich do obiektów oraz updatowania i dodawania do bazy danych
    {
        try
        {
            location = await Geocode(inputCity);

            var lat_fromgeo = location.Latitude;
            var lon_fromgeo = location.Longitude;

            Console.WriteLine(inputCity);
            Console.WriteLine(lat_fromgeo);
            Console.WriteLine(lon_fromgeo);

            var adres = await ReverseGeocode(lat_fromgeo, lon_fromgeo);

            Console.Write(adres);

            string apiKey = "84c28f5c4cc0e8e22f5c365f20443e98";
            string url = $"https://api.openweathermap.org/data/3.0/onecall?lat={lat_fromgeo}&lon={lon_fromgeo}&appid={apiKey}";
            weatherData = await Http.GetFromJsonAsync<WeatherResponse>(url); //pobieranie danych z API

            if (weatherData != null && weatherData.Daily != null && weatherData.Hourly != null) //Jeżeli nie jest puste to
            {
                foreach (var day in weatherData.Daily) //Dla każdego pobranego dnia musimy uzupełnić pole DateDaily ( bo nie występuje w odpowiedzi API a jest potrzebne dla bazy danych)
                {

                    var dateTime = DateTimeOffset.FromUnixTimeSeconds(day.Dt).DateTime.ToLocalTime(); //zamiana czasu unixowego na DateTime

                    Console.WriteLine(weatherData.Lat);
                    Console.WriteLine(weatherData.Lon);
                    Console.WriteLine(inputCity);

                    day.LocationName = inputCity;
                    day.DateDaily = dateTime.Date; //dodanie wyłącznie daty do pola DateDaily czyli dodajemy wyłącznie 12-02-2024 (potem jest jeszcze czas ale zawsze będzie 00:00:00)

                    await WeatherService.UpdateOrAddWeatherDailyAsync(day); //dodajemy do bazy dancyh
                }

                foreach (var hour in weatherData.Hourly) //to samo co u góry tylko dla każdej godziny z wyjątkiem takim że oprócz uzupełniania DateHourly uzupełniamy też Time czyli rozdzielamy datę na datę i godzinę
                {
                    var dateTime = DateTimeOffset.FromUnixTimeSeconds(hour.Dt).DateTime.ToLocalTime();

                    hour.DateHourly = dateTime.Date; //21-01-2024 00:00:00
                    hour.Time = dateTime.TimeOfDay; //04:12:42
                    
                    Console.WriteLine(inputCity);

                    hour.LocationName = inputCity;

                    await WeatherService.UpdateOrAddWeatherHourlyAsync(hour); //dodanie do bazy danych
                }
            }

        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Failed to load weather data: {ex.Message}");
        }
        return weatherData; //zwracamy cały obiekt
    }

    private string FormatTemperature(double kelvin) // zamiana temperatury z kelvinów na celcjusze ale na razie tego nie wykorzystujemy
    {
        return (kelvin - 273.15).ToString("N2");
    }

    // metoda wysyłająca zapytanie do API openstreetmap zamieniająca stringa - adres np. Warszawa na lat i lon => POTRZEBNE W PRZYSZŁOŚCI DO WYSYŁANIA ZAPYTAŃ NA KONKRETNE LOKALIZACJE
    private static async Task<Location> Geocode(string address)
    {
        string url = "https://nominatim.openstreetmap.org/search";
        string query = $"?format=json&q={Uri.EscapeDataString(address)}";

        using (HttpClient client = new HttpClient())
        {
            client.DefaultRequestHeaders.Add("User-Agent", "C#.net Weather App Student Project (264237@student.pwr.edu.pl)");

            HttpResponseMessage response = await client.GetAsync(url + query);

            if (response.IsSuccessStatusCode)
            {
                string jsonResult = await response.Content.ReadAsStringAsync();
                var results = JsonConvert.DeserializeObject<NominatimResponseGeocode[]>(jsonResult);

                if (results.Length > 0)
                {
                    return new Location { Latitude = double.Parse(results[0].lat, CultureInfo.InvariantCulture), Longitude = double.Parse(results[0].lon, CultureInfo.InvariantCulture) };
                }
                else
                {
                    return null;
                }
            }
            return null;
        }
    }

    //metoda zamieniająca lat i lon na adres słownie np. Warszawa => POTRZEBNE WYŁĄCZNIE DO ZAPISU DO BAZY DANYCH
    private static async Task<string> ReverseGeocode(double lat, double lon)
    {
        string url = "https://nominatim.openstreetmap.org/reverse";
        string query = $"?lat={lat.ToString(CultureInfo.InvariantCulture)}&lon={lon.ToString(CultureInfo.InvariantCulture)}&format=json&zoom=10";

        using (HttpClient client = new HttpClient())
        {
            client.DefaultRequestHeaders.Add("User-Agent", "C#.net Weather App Student Project (264237@student.pwr.edu.pl)");
            HttpResponseMessage response = await client.GetAsync(url + query);

            if (response.IsSuccessStatusCode)
            {
                string jsonResult = await response.Content.ReadAsStringAsync();
                var result = JsonConvert.DeserializeObject<NominatimResponseReverseGeocode>(jsonResult);

                if (result != null && result.Address != null && result.Address.City != null)
                {
                    return result.Address.City;
                }
                else
                {
                    return "No location found :(";
                }
            }
            else
            {
                string errorMessage = await response.Content.ReadAsStringAsync();  // To pokaże błąd z API

                Console.WriteLine(errorMessage);

                return "Zesrało się :(";
            }
        } 
        //dorobić funkcje, które wyciągają inne dane niż temperatura i data
        //wyświetlić wszystkie dane jakie mogę żeby zobaczyć czy sa dobrze przekonwertowane
        //sprawdzić czy w odpowiedzi z bazy danych jak pobieramy całą tabele daily są dla każdego dnia dane dla godzin


    } //zrobić interfejs do pobierania danych z bazy danych
}
